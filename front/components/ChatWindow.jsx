import { useState, useEffect } from "react";
import styles from "../styles/ChatWindow.module.css";
import axios from "axios";
import { motion, AnimatePresence } from "framer-motion";
import URLS from '../config';

export default function ChatWindow({
                                       newChatTrigger,
                                       selectedSessionId,
                                       theme,
                                       isNewChat,
                                       setIsNewChat,
                                       setRefreshSessionList,
                                       isGuest
                                   }) {
    const [messages, setMessages] = useState([]);
    const [input, setInput] = useState("");
    const [isSending, setIsSending] = useState(false);
    const [sessionId, setSessionId] = useState(null);
    const [showIntro, setShowIntro] = useState(true); // üíñ Intro Î≥¥Ïó¨Ï§ÑÏßÄ Ïó¨Î∂Ä
    const [showInputBox, setShowInputBox] = useState(false);
    const [introClicked, setIntroClicked] = useState(false);
    const [introVisible, setIntroVisible] = useState(true);
    const [isBotTyping, setIsBotTyping] = useState(false);
    const [typingDots, setTypingDots] = useState("");
    const [botTypingText, setBotTypingText] = useState(""); // Ï†êÏ†ê Ï∞çÌûê ÌÖçÏä§Ìä∏

    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const formattedTime = `${hours < 12 ? 'Ïò§Ï†Ñ' : 'Ïò§ÌõÑ'} ${hours % 12 || 12}:${minutes.toString().padStart(2, '0')}`;

    const calcDelay = (char) => {
        const base = 30;
        const punctuationPause = /[.,!?]/.test(char) ? 100 : 0;

        return base + punctuationPause;
    };
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    const typeText = async (fullReplyText) => {
        setBotTypingText("");
        setIsBotTyping(true);

        const sentences = fullReplyText.split(/(?<=[.!?])\s+/); // Î¨∏Ïû• Îã®ÏúÑ Î∂ÑÎ¶¨

        for (let i = 0; i < sentences.length; i++) {
            const sentence = sentences[i].trim();
            if (!sentence) continue;

            const chars = sentence.split("");
            let rendered = "";

            for (let j = 0; j < chars.length; j++) {
                rendered += chars[j];
                setBotTypingText(rendered);
                await sleep(calcDelay(chars[j]));
            }

            // ÎßêÌíçÏÑ† Ï∂îÍ∞Ä
            const botMessage = {
                id: Date.now() + i,
                sender: "bot",
                text: sentence,
            };
            setMessages((prev) => [...prev, botMessage]);
            setBotTypingText("");
            await sleep(300); // Î¨∏Ïû• Í∞Ñ ÎîúÎ†àÏù¥
        }

        setIsBotTyping(false);
    };

    useEffect(() => {
        if (!isBotTyping) {
            setTypingDots("");
            return;
        }

        const dotInterval = setInterval(() => {
            setTypingDots((prev) => {
                if (prev.length >= 3) return "";
                return prev + ".";
            });
        }, 500); // 0.5Ï¥àÎßàÎã§ Ï†ê Ï∂îÍ∞Ä

        return () => clearInterval(dotInterval);
    }, [isBotTyping]);

    useEffect(() => {
        if (!selectedSessionId || isNewChat) return;
        setMessages([]);
        setSessionId(null); // ÏÉà ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî
        const storedUser = JSON.parse(localStorage.getItem("user"));
        if (!storedUser || storedUser.guest) {
            setMessages([]);
            setSessionId(selectedSessionId);
            setShowIntro(true);
            return;
        }

        const fetchMessages = async () => {
            setSessionId(selectedSessionId);
            try {
                const res = await fetch(`${URLS.BACK}/api/chat/history?sessionId=${selectedSessionId}`, {
                    headers: {
                        "Authorization": `Bearer ${storedUser.token}`
                    }
                });
                console.log("üîé ÏöîÏ≤≠ Î≥¥ÎÇ∏ ÏÑ∏ÏÖòID:", selectedSessionId);
                const data = await res.json();
                console.log("‚úÖ Î∂àÎü¨Ïò® Ï±ÑÌåÖ ÎÇ¥Ïó≠", data);
                const parsed = [];
                console.log("üîç Ïã§Ï†ú Î∞õÏùÄ Î©îÏãúÏßÄÎì§", parsed);

                data.forEach(d => {
                    if (d.sessionId !== selectedSessionId) {
                        console.warn("‚ùå Îã§Î•∏ ÏÑ∏ÏÖò ID Î∞úÍ≤¨!", {
                            expected: selectedSessionId,
                            actual: d.sessionId,
                            diff: selectedSessionId.split('').map((c, i) => c === d.sessionId[i] ? ' ' : '^').join('')
                        });
                    }
                });
                data.forEach((msg, index) => {
                    parsed.push({
                        id: msg.id ? `msg_${msg.id}` : `msg_${Date.now()}_${index}`,
                        sender: "user",
                        text: msg.message,
                        timestamp: msg.timestamp,
                        sessionId: msg.sessionId  // ‚úÖ Ï∂îÍ∞Ä
                    });

                    if (msg.response) {
                        const sentences = msg.response.split(/(?<=[.!?])\s+/).filter(Boolean);
                        sentences.forEach((sentence, i) => {
                            parsed.push({
                                id: msg.id ? `resp_${msg.id}_${i}` : `resp_${Date.now()}_${index}_${i}`,
                                sender: "bot",
                                text: sentence.trim(),
                                timestamp: msg.timestamp,
                                sessionId: msg.sessionId
                            });
                        });
                    }
                });
                console.log("üîç ÏùëÎãµÏóê Ìè¨Ìï®Îêú ÏÑ∏ÏÖòIDÎì§:", parsed.map(m => m.sessionId));
                parsed.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                setMessages(parsed);
                setSessionId(selectedSessionId);
                setShowIntro(parsed.length === 0);
            } catch (error) {
                console.error("Ï±ÑÌåÖ Í∏∞Î°ù Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:", error);
                setMessages([]);
                setShowIntro(true);
            }
        };

        fetchMessages();
    }, [selectedSessionId]);

    useEffect(() => {
        if (newChatTrigger > 0 && isNewChat) {
            setMessages([]);
            setShowIntro(true);
            setIntroClicked(false);
            setIntroVisible(true);
            setIsNewChat(false);  // ‚úÖ Ï¥àÍ∏∞Ìôî ÎÅùÎÇ¨ÏúºÎ©¥ Îã§Ïãú falseÎ°ú
        }
    }, [newChatTrigger]);

    useEffect(() => {
        if (!sessionId && selectedSessionId) {
            setSessionId(selectedSessionId);
        }
    }, [sessionId, selectedSessionId]);

    const fetchGreeting = async () => {
        const storedUser = JSON.parse(localStorage.getItem("user"));
        const userId = storedUser?.id;
        try {
            const res = await fetch(`${URLS.MODEL}/gen`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    user_info: {
                        user_id: userId
                    },
                    query: {
                        user_input: "<SOS>"
                    }
                })
            });
            const data = await res.json();  // üí° JSON ÌååÏã±

            if (data.response) {
            await typeText(data.response);  // ‚ú® ÌÉÄÏù¥Ìïë Ï∂úÎ†•
            setShowIntro(false); 
            setShowInputBox(true); 
        }
        } catch (error) {
            console.error("Ï¥àÍ∏∞ Ïù∏ÏÇ¨Îßê Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:", error);
            setMessages([]);
            setShowIntro(false);
            setShowInputBox(true); // ‚úÖ Ïù∏Ìä∏Î°ú ÏÇ¨ÎùºÏßÑ ÌõÑ ÏûÖÎ†•Ï∞Ω ÌëúÏãú
        }
    };
        
    const handleIntroClick = async () => {
        setIntroClicked(true); // ÌÅ¥Î¶≠ÌñàÏúºÎãàÍπå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë

        try {
            const storedUser = JSON.parse(localStorage.getItem("user"));
            const userId = storedUser?.id;
            const sessionIdToSend = selectedSessionId || sessionId;

            const payload = {
                user_info: {
                    user_id: String(userId),
                },
                session_info: {
                    session_id: sessionIdToSend,
                    insight: {
                    },
                    selected_supervisor: "None",
                    cbt_info: {
                        "cbt_log": {},
                        "basic_memory": [],
                        "cd_memory": []
                    },
                    pf_rating: {
                    },
                    ipt_log: {
                        history: []
                    }
                },
                dialog_history: {
                    history: []
                }
            };

            console.log("üì§ NewCHatÏóê ÎåÄÌïú selectSession ÏöîÏ≤≠ payload:", payload);

            await fetch(`${URLS.MODEL}/select_session`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    user_info: {
                        user_id: String(userId),
                    },
                    session_info: {
                        session_id: sessionIdToSend,
                        insight:{},
                        selected_supervisor: "None",
                        cbt_info:{
                            cbt_log:{},
                            basic_memory:[],
                            cd_memory:[]
                        },
                        pf_rating:{},
                        ipt_log:{"history": []
                        }
                    },
                    dialog_history: {
                        history:[]
                    },
                }),
            });

            console.log("‚úÖ Ïù∏Ìä∏Î°ú ÌÅ¥Î¶≠ Ïãú Î™®Îç∏ ÏÑúÎ≤ÑÏóê Ï¥àÍ∏∞ ÏÑ∏ÏÖò Ï†ÑÏÜ° ÏôÑÎ£å");
        } catch (error) {
            console.error("‚ùå Ïù∏Ìä∏Î°ú ÌÅ¥Î¶≠ Ïãú Î™®Îç∏ ÏÑúÎ≤Ñ Ï†ÑÏÜ° Ïã§Ìå®:", error);
        }

        // 0.8Ï¥à Îí§Ïóê Ïù∏Ìä∏Î°ú Î∞ïÏä§ Ï†úÍ±∞
        setTimeout(() => {
            setIntroVisible(false);
        }, 800);

        // 1Ï¥à Îí§Ïóê Í∑∏Î¶¨ÌåÖ Î©îÏãúÏßÄ Ï∂úÎ†• ÏãúÏûë
        setTimeout(() => {
            fetchGreeting(); // ‚ú® ÌÉÄÏù¥Ìïë Ïï†ÎãàÎ©îÏù¥ÏÖò Ìè¨Ìï®Îêú Ïù∏ÏÇ¨ Ï∂úÎ†•
        }, 1000);
    };

    async function fetchTitleFromLLM(fullMessages) {
        try {
            const chatText = fullMessages
                .map((m) => `${m.sender === "user" ? "ÏÇ¨Ïö©Ïûê" : "ÏÉÅÎã¥ÏÇ¨"}: ${m.text}`)
                .join("\n");

            const res = await fetch("/api/title", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ content: chatText }),
            });

            const data = await res.json();
            return data.title;
        } catch (e) {
            console.error("Ï†úÎ™© ÏÉùÏÑ± Ïã§Ìå®:", e);
            return "";
        }
    }
    const handleSend = async () => {
        const currentSessionId = selectedSessionId || sessionId;
        const storedUser = JSON.parse(localStorage.getItem("user"));
        const userId = storedUser?.id;

        if (!input.trim() || !currentSessionId) return;

        const userMessage = {
            id: Date.now(),
            sender: "user",
            text: input,
            time: formattedTime,
        };

        const newMessages = [...messages, userMessage];

        setMessages(newMessages);
        setInput("");
        setBotTypingText("");
        setIsBotTyping(true);
        setShowIntro(false);
        setIsSending(true);

        try {
            // 1. Î™®Îç∏ ÏùëÎãµ Î∞õÍ∏∞
            const res = await fetch("/api/chat", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    user_info: {
                        user_id: userId
                    },
                    query: {
                        user_input: input
                    }
                })
            });
            console.log("üì¶ ÏöîÏ≤≠ Î∞îÎîî:", { message: input, userId });
            const data = await res.json();
            const replyText = data.message || "ÎãµÎ≥ÄÏùÑ Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏñ¥Ïöî.";

            await typeText(replyText);

            // 2. Î©îÏãúÏßÄ UI Íµ¨ÏÑ±
            const botMessages = replyText
                .split(/(?<=[.!?])\s+/)
                .filter(Boolean)
                .map((text, i) => ({
                    id: Date.now() + i + 1,
                    sender: "bot",
                    text: text.trim(),
                }));

            const updatedMessages = [...newMessages, ...botMessages];
            setMessages(updatedMessages);

            // 3. title ÏÉùÏÑ±
            const generatedTitle = await fetchTitleFromLLM(updatedMessages);
            console.log("üéØ ÏÉùÏÑ±Îêú Ï†úÎ™©:", generatedTitle);

            // 4. Î©îÏãúÏßÄ Ï†ÄÏû• (Ìïú Î≤àÎßå)
            const storedUser = JSON.parse(localStorage.getItem("user"));

            await fetch(`${URLS.BACK}/api/chat`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${storedUser.token}`
                },
                body: JSON.stringify({
                    message: userMessage.text,
                    response: replyText,
                    sessionId: currentSessionId,
                    title: generatedTitle || userMessage.text.slice(0, 30),
                    insight: data.insight || "",
                    cognitiveDistortion: data.cognitiveDistortion || "",
                    severity: data.severity || 0
                })
            });

            await new Promise((resolve) => setTimeout(resolve, 300)); // üí° 300ms ÎîúÎ†àÏù¥ Ï∂îÍ∞Ä
            await fetch(`${URLS.BACK}/api/chat/title`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${storedUser.token}`,
                },
                body: JSON.stringify({
                    sessionId: currentSessionId,
                    title: generatedTitle,
                }),
            });

        } catch (e) {
            console.error("Î©îÏãúÏßÄ Ï†ÄÏû• Ï§ë Ïò§Î•ò:", e);
        } finally {
            setIsBotTyping(false);
            setIsSending(false);
        }
    };

    if (!sessionId) return <div className={styles.chatContainer}>Ï±ÑÌåÖ ÏÑ∏ÏÖòÏùÑ Ï¥àÍ∏∞Ìôî Ï§ëÏûÖÎãàÎã§...</div>;

    return (
        <div className={`${styles.chatContainer} ${styles[theme]}`}>
            <AnimatePresence>
                {messages.length === 0 && showIntro && introVisible && (
                    <motion.div
                        initial={{ opacity: 0, y: 10 }}
                        animate={{ opacity: 1, y: 10 }}
                        exit={{ opacity: 0, y: -30}}
                        transition={{ duration: 0.8, ease: "easeInOut" }}
                        className={`${styles.emptyMessageBox} ${introClicked ? styles.fadeOutUp : ''}`}
                        onClick={() => {
                            handleIntroClick();
                            setIntroClicked(true);
                        }}
                        style={{ cursor: "pointer" }}
                    >
                        <div className={styles.heartEmoji}>üíñ</div>
                        <h2 className={styles.emptyTitle}>Let me hear your heart</h2>
                        <p className={styles.emptyDescription}>
                            ÎßàÏùåÏÜç Ïù¥ÏïºÍ∏∞Î•º ÎÇòÎà†Î≥¥ÏÑ∏Ïöî.<br />Ï†úÍ∞Ä Í≤ΩÏ≤≠ÌïòÍ≥† ÏúÑÎ°úÌï¥ÎìúÎ¶¥Í≤åÏöî.
                        </p>
                    </motion.div>
                )}
            </AnimatePresence>

            <div className={styles.messageList}>
                {messages.map((msg) => {
                    // ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄÎäî Î¨¥Ï°∞Í±¥ Î≥¥Ïó¨Ï£ºÍ≥†, bot Î©îÏãúÏßÄÎßå Îπà ÌÖçÏä§Ìä∏ ÌïÑÌÑ∞ÎßÅ
                    if (msg.sender === "bot" && !msg.text?.trim()) return null;

                    return (
                        <motion.div
                            key={msg.id}
                            initial={{ opacity: 1 }}
                            animate={{ opacity: 1 }}
                            transition={{ duration: 1, ease: "easeInOut" }}
                            className={`${styles.messageBubble} ${
                                msg.sender === "user" ? styles.userMessage : styles.botMessage
                            }`}
                        >
                            <div>{msg.text || " "}</div>
                            {msg.sender === "user" && msg.time && (
                                <div className={styles.timeStamp}>{msg.time}</div>
                            )}
                        </motion.div>
                    );
                })}

                {/* ÏÉÅÎã¥ÏÇ¨ ÏûÖÎ†• Ï§ë ÌëúÏãú */}
                {isBotTyping && !botTypingText && (
                    <motion.div
                        key="typing"
                        className={`${styles.messageBubble} ${styles.botMessage}`}
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ duration: 1.5 }}
                    >
                        ÏÉÅÎã¥ÏÇ¨Í∞Ä ÏûÖÎ†• Ï§ëÏûÖÎãàÎã§{typingDots}
                    </motion.div>
                )}

                {/* ÎãµÎ≥Ä ÌÖçÏä§Ìä∏ Ï†êÏ†ê Ï∂úÎ†• */}
                {isBotTyping && botTypingText && (
                    <motion.div
                        key="botReplyTyping"
                        className={`${styles.messageBubble} ${styles.botMessage}`}
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ duration: 1 }}
                    >
                        {botTypingText}
                    </motion.div>
                )}
            </div>

            <AnimatePresence>
                {(messages.length > 0 || introClicked) && (
                    <motion.div
                        initial={{ opacity: 0, y: 150,x: "-30%" }}
                        animate={{ opacity: 1, y: 0, x: "-30%" }}
                        exit={{ opacity: 0, y: 150, x: "-30%" }}
                        transition={{ duration: 1, ease: "easeInOut" }}
                        className={`${styles.inputWrapper} ${introClicked && messages.length === 0 ? styles.slideUp : messages.length === 0 ? styles.hidden : ''}`}
                    >
                        <div className={styles.inputBox}>
                            <img
                                src="/sound_of_mind.svg"
                                alt="Sound of Mind"
                                className={styles.inputIcon}
                            />
                            <input
                                type="text"
                                placeholder="ÎßàÏùåÏùò ÏÜåÎ¶¨Î•º Îì§Î†§Ï£ºÏÑ∏Ïöî"
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                onKeyDown={(e) => {
                                    if (e.key === "Enter" && !e.nativeEvent.isComposing && !isSending && sessionId) {
                                        handleSend();
                                    }
                                }}
                                disabled={isSending || !sessionId}
                                className={styles.inputField}
                            />
                            <button
                                onClick={handleSend}
                                disabled={isSending || !sessionId}
                                className={styles.sendButton}
                            >
                                <img src="/send.svg" alt="Send" className={styles.sendIcon} />
                            </button>
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}